--- isa_export.ml.orig	2019-02-07 15:28:10.432994990 +0000
+++ isa_export.ml	2019-02-07 15:28:14.189088180 +0000
@@ -1,3 +1,19 @@
+(** This file is exported from Isabelle, and lightly patched (eg to
+   include this comment!). The OCaml interfaces wrap this basic
+   functionality. *)
+
+let check_flag = ref true
+
+module type MONAD = sig
+   type ('a, 'b) mm
+   val bind : ('a -> ('b, 'c) mm) -> ('a, 'c) mm -> ('b, 'c) mm
+   val fmap : ('a -> 'b) -> ('a, 'c) mm -> ('b, 'c) mm
+   val return : 'a -> ('a, 'b) mm
+end
+
+
+
+
 module Fun : sig
   val id : 'a -> 'a
   val comp : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
@@ -266,7 +282,7 @@ end;; (*struct Set*)
 module Constants_and_size_types : sig
   type constants =
     Make_constants of Arith.nat * Arith.nat * Arith.nat * Arith.nat
-  type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf
+  type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf [@@deriving yojson]
   val make_constants :
     Arith.nat -> Arith.nat -> Arith.nat -> Arith.nat -> constants
   val max_leaf_size : constants -> Arith.nat
@@ -278,7 +294,7 @@ end = struct
 type constants =
   Make_constants of Arith.nat * Arith.nat * Arith.nat * Arith.nat;;
 
-type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf;;
+type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf [@@deriving yojson];;
 
 let rec make_constants a b c d = Make_constants (a, b, c, d);;
 
@@ -302,7 +318,7 @@ let rec is_none = function Some x -> fal
 end;; (*struct Option*)
 
 module A_start_here : sig
-  type error = String_error of string
+  type error = String_error of string [@@deriving yojson]
   val from_to : Arith.nat -> Arith.nat -> Arith.nat list
   val is_Nil : 'a list -> bool
   val rev_apply : 'a -> ('a -> 'b) -> 'b
@@ -316,7 +332,7 @@ module A_start_here : sig
   val get_check_flag : unit -> bool
 end = struct
 
-type error = String_error of string;;
+type error = String_error of string [@@deriving yojson];;
 
 let rec from_to x y = Lista.upt x (Arith.suc y);;
 
@@ -324,12 +340,12 @@ let rec is_Nil x = (match x with [] -> t
 
 let rec rev_apply x f = f x;;
 
-let rec failwitha x = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec failwitha x = failwith x;;
 
 let rec iter_step
   f x = (let a = f x in (match a with None -> x | Some aa -> iter_step f aa));;
 
-let rec check_true f = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec check_true f = if !check_flag then (let b = f () in assert(b);b) else true;;
 
 let rec assert_true b = (if b then b else failwitha "assert_true");;
 
@@ -365,12 +381,12 @@ let from_to_tests : bool
            in
           true));;
 
-let rec get_check_flag uu = failwitha "FIXME patch";;
+let rec get_check_flag uu = !check_flag
 
 end;; (*struct A_start_here*)
 
 module Key_value : sig
-  type compare_t = LT | EQ | GT
+  type compare_t = LT | EQ | GT [@@deriving yojson]
   val key_eq : ('a -> 'a -> Arith.int) -> 'a -> 'a -> bool
   val key_le : ('a -> 'a -> Arith.int) -> 'a -> 'a -> bool
   val key_lt : ('a -> 'a -> Arith.int) -> 'a -> 'a -> bool
@@ -383,7 +399,7 @@ module Key_value : sig
   val kvs_insert_tests : bool
 end = struct
 
-type compare_t = LT | EQ | GT;;
+type compare_t = LT | EQ | GT [@@deriving yojson];;
 
 let rec key_eq ord k1 k2 = Arith.equal_int (ord k1 k2) Arith.zero_int;;
 
@@ -539,7 +555,7 @@ let kvs_insert_tests : bool
 end;; (*struct Key_value*)
 
 module Stacks_and_frames : sig
-  type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd)))
+  type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd))) [@@deriving yojson]
   val dest_Frm : ('a, 'b, 'c, 'd) stk_frame -> 'a * ('b * ('c * 'd))
   val make_frame :
     ('a -> 'a -> Arith.int) ->
@@ -553,7 +569,7 @@ module Stacks_and_frames : sig
       'b list * 'a list
 end = struct
 
-type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd)));;
+type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd))) [@@deriving yojson];;
 
 let rec dest_Frm (Frm (a, (b, (c, d)))) = (a, (b, (c, d)));;
 
@@ -594,7 +610,7 @@ end;; (*struct Stacks_and_frames*)
 
 module Disk_node : sig
   type ('a, 'b, 'c, 'd) dnode = Disk_node of ('a list * 'b list) |
-    Disk_leaf of 'c
+    Disk_leaf of 'c  [@@deriving yojson]
   type ('a, 'b, 'c) leaf_ops =
     Make_leaf_ops of
       ('a -> 'b -> 'c -> 'c) * ('c -> Arith.nat) * ('c -> ('a * 'b) list) *
@@ -608,7 +624,7 @@ module Disk_node : sig
 end = struct
 
 type ('a, 'b, 'c, 'd) dnode = Disk_node of ('a list * 'b list) |
-  Disk_leaf of 'c;;
+  Disk_leaf of 'c  [@@deriving yojson];;
 
 type ('a, 'b, 'c) leaf_ops =
   Make_leaf_ops of
@@ -641,7 +657,7 @@ module Find_state : sig
     | F_finished of
         ('b * ('a * ('b * ('c * (('b list * 'a list), 'b, ('a list * 'b list),
                                   'b)
-                                  Stacks_and_frames.stk_frame list))))
+                                  Stacks_and_frames.stk_frame list))))  [@@deriving yojson]
   val dest_F_finished :
     ('a, 'b, 'c, unit) find_state ->
       ('b * ('a * ('b * ('c * (('b list * 'a list), 'b, ('a list * 'b list), 'b)
@@ -655,7 +671,7 @@ type ('a, 'b, 'c, 'd) find_state =
                         Stacks_and_frames.stk_frame list)))
   | F_finished of
       ('b * ('a * ('b * ('c * (('b list * 'a list), 'b, ('a list * 'b list), 'b)
-                                Stacks_and_frames.stk_frame list))));;
+                                Stacks_and_frames.stk_frame list))))  [@@deriving yojson];;
 
 let rec dest_F_finished
   fs = (match fs with F_down _ -> None
@@ -667,14 +683,14 @@ let rec make_initial_find_state k r = F_
 end;; (*struct Find_state*)
 
 module Insert_state : sig
-  type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c))
+  type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c)) [@@deriving yojson]
   type ('a, 'b, 'c, 'd) insert_state =
     I_down of (('a, 'c, 'd, unit) Find_state.find_state * 'b) |
     I_up of
       (('a, 'b, 'c) i12_t *
         (('c list * 'a list), 'c, ('a list * 'c list), 'c)
           Stacks_and_frames.stk_frame list)
-    | I_finished of 'c | I_finished_with_mutate
+    | I_finished of 'c | I_finished_with_mutate  [@@deriving yojson]
   val split_leaf :
     Constants_and_size_types.constants ->
       ('a * 'b) list -> ('a * 'b) list * ('a * ('a * 'b) list)
@@ -685,7 +701,7 @@ module Insert_state : sig
     'a -> 'b -> 'c -> ('b, 'c, 'a, 'd) insert_state
 end = struct
 
-type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c));;
+type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c)) [@@deriving yojson];;
 
 type ('a, 'b, 'c, 'd) insert_state =
   I_down of (('a, 'c, 'd, unit) Find_state.find_state * 'b) |
@@ -693,7 +709,7 @@ type ('a, 'b, 'c, 'd) insert_state =
     (('a, 'b, 'c) i12_t *
       (('c list * 'a list), 'c, ('a list * 'c list), 'c)
         Stacks_and_frames.stk_frame list)
-  | I_finished of 'c | I_finished_with_mutate;;
+  | I_finished of 'c | I_finished_with_mutate [@@deriving yojson];;
 
 let rec split_leaf
   cs kvs =
@@ -747,7 +763,7 @@ end;; (*struct Insert_state*)
 
 module Delete_state : sig
   type ('a, 'b, 'c) del_t = D_small_leaf of ('a * 'b) list |
-    D_small_node of ('a list * 'c list) | D_updated_subtree of 'c
+    D_small_node of ('a list * 'c list) | D_updated_subtree of 'c  [@@deriving yojson]
   type ('a, 'b, 'c, 'd) delete_state =
     D_down of (('a, 'c, 'd, unit) Find_state.find_state * 'c) |
     D_up of
@@ -755,13 +771,13 @@ module Delete_state : sig
         ((('c list * 'a list), 'c, ('a list * 'c list), 'c)
            Stacks_and_frames.stk_frame list *
           'c))
-    | D_finished of 'c
+    | D_finished of 'c  [@@deriving yojson]
   val dest_D_finished : ('a, 'b, 'c, 'd) delete_state -> 'c option
   val make_initial_delete_state : 'a -> 'b -> ('b, 'c, 'a, 'd) delete_state
 end = struct
 
 type ('a, 'b, 'c) del_t = D_small_leaf of ('a * 'b) list |
-  D_small_node of ('a list * 'c list) | D_updated_subtree of 'c;;
+  D_small_node of ('a list * 'c list) | D_updated_subtree of 'c  [@@deriving yojson];;
 
 type ('a, 'b, 'c, 'd) delete_state =
   D_down of (('a, 'c, 'd, unit) Find_state.find_state * 'c) |
@@ -770,7 +786,7 @@ type ('a, 'b, 'c, 'd) delete_state =
       ((('c list * 'a list), 'c, ('a list * 'c list), 'c)
          Stacks_and_frames.stk_frame list *
         'c))
-  | D_finished of 'c;;
+  | D_finished of 'c [@@deriving yojson];;
 
 let rec dest_D_finished
   x = (match x with D_down _ -> None | D_up _ -> None
@@ -791,7 +807,7 @@ end;; (*struct Sum_Type*)
 
 module Tree : sig
   type ('a, 'b) tree = Node of ('a list * ('a, 'b) tree list) |
-    Leaf of ('a * 'b) list
+    Leaf of ('a * 'b) list [@@deriving yojson]
   val wf_tree :
     Constants_and_size_types.constants ->
       Constants_and_size_types.min_size_t option ->
@@ -801,7 +817,7 @@ module Tree : sig
 end = struct
 
 type ('a, 'b) tree = Node of ('a list * ('a, 'b) tree list) |
-  Leaf of ('a * 'b) list;;
+  Leaf of ('a * 'b) list [@@deriving yojson];;
 
 let rec tree_to_subtrees
   t0 = (match t0
@@ -1010,6 +1026,7 @@ let rec return x = failwith "undefined";
 
 end;; (*struct Monad*)
 
+module Make(Monad:MONAD) = struct
 module Post_monad : sig
   type ('a, 'b, 'c) store_ops =
     Make_store_ops of
@@ -1799,3 +1816,6 @@ let rec insert
                   (Monad.bind (fun _ -> Monad.return None))))));;
 
 end;; (*struct Insert*)
+
+
+end (* Make *)
