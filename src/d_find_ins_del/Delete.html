<html>
<head>
<title>Insert.thy</title>
<style type="text/css"><!--

.syntax-NULL {
  color: #ff000000;
}
.syntax-COMMENT1 {
  color: #ffcc0000;
}
.syntax-COMMENT2 {
  color: #ffff8400;
}
.syntax-COMMENT3 {
  color: #ff6600cc;
}
.syntax-COMMENT4 {
  color: #ffcc6600;
}
.syntax-DIGIT {
  color: #ffff0000;
}
.syntax-FUNCTION {
  color: #ff9966ff;
}
.syntax-INVALID {
  background: #ffffffcc;
  color: #ffff0066;
}
.syntax-KEYWORD1 {
  color: #ff006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #ff009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #ff0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #ff66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #ff02b902;
}
.syntax-LITERAL1 {
  color: #ffff00cc;
}
.syntax-LITERAL2 {
  color: #ffcc00cc;
}
.syntax-LITERAL3 {
  color: #ff9900cc;
}
.syntax-LITERAL4 {
  color: #ff6600cc;
}
.syntax-MARKUP {
  color: #ff0000ff;
}
.syntax-OPERATOR {
  color: #ff000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #ff000000;
}
.syntax-COMMENT1 {
  color: #ffcc0000;
}
.syntax-COMMENT2 {
  color: #ffff8400;
}
.syntax-COMMENT3 {
  color: #ff6600cc;
}
.syntax-COMMENT4 {
  color: #ffcc6600;
}
.syntax-DIGIT {
  color: #ffff0000;
}
.syntax-FUNCTION {
  color: #ff9966ff;
}
.syntax-INVALID {
  background: #ffffffcc;
  color: #ffff0066;
}
.syntax-KEYWORD1 {
  color: #ff006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #ff009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #ff0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #ff66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #ff02b902;
}
.syntax-LITERAL1 {
  color: #ffff00cc;
}
.syntax-LITERAL2 {
  color: #ffcc00cc;
}
.syntax-LITERAL3 {
  color: #ff9900cc;
}
.syntax-LITERAL4 {
  color: #ff6600cc;
}
.syntax-MARKUP {
  color: #ff0000ff;
}
.syntax-OPERATOR {
  color: #ff000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #ff000000;
}
.syntax-COMMENT1 {
  color: #ffcc0000;
}
.syntax-COMMENT2 {
  color: #ffff8400;
}
.syntax-COMMENT3 {
  color: #ff6600cc;
}
.syntax-COMMENT4 {
  color: #ffcc6600;
}
.syntax-DIGIT {
  color: #ffff0000;
}
.syntax-FUNCTION {
  color: #ff9966ff;
}
.syntax-INVALID {
  background: #ffffffcc;
  color: #ffff0066;
}
.syntax-KEYWORD1 {
  color: #ff006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #ff009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #ff0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #ff66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #ff02b902;
}
.syntax-LITERAL1 {
  color: #ffff00cc;
}
.syntax-LITERAL2 {
  color: #ffcc00cc;
}
.syntax-LITERAL3 {
  color: #ff9900cc;
}
.syntax-LITERAL4 {
  color: #ff6600cc;
}
.syntax-MARKUP {
  color: #ff0000ff;
}
.syntax-OPERATOR {
  color: #ff000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #ff000000;
  font-weight: bold;
}
.syntax-COMMENT1 {
  color: #ffcc0000;
  font-weight: bold;
}
.syntax-COMMENT2 {
  color: #ffff8400;
  font-weight: bold;
}
.syntax-COMMENT3 {
  color: #ff6600cc;
  font-weight: bold;
}
.syntax-COMMENT4 {
  color: #ffcc6600;
  font-weight: bold;
}
.syntax-DIGIT {
  color: #ffff0000;
  font-weight: bold;
}
.syntax-FUNCTION {
  color: #ff9966ff;
  font-weight: bold;
}
.syntax-INVALID {
  background: #ffffffcc;
  color: #ffff0066;
  font-weight: bold;
}
.syntax-KEYWORD1 {
  color: #ff006699;
}
.syntax-KEYWORD2 {
  color: #ff009966;
}
.syntax-KEYWORD3 {
  color: #ff0099ff;
}
.syntax-KEYWORD4 {
  color: #ff66ccff;
}
.syntax-LABEL {
  color: #ff02b902;
  font-weight: bold;
}
.syntax-LITERAL1 {
  color: #ffff00cc;
  font-weight: bold;
}
.syntax-LITERAL2 {
  color: #ffcc00cc;
  font-weight: bold;
}
.syntax-LITERAL3 {
  color: #ff9900cc;
  font-weight: bold;
}
.syntax-LITERAL4 {
  color: #ff6600cc;
  font-weight: bold;
}
.syntax-MARKUP {
  color: #ff0000ff;
  font-weight: bold;
}
.syntax-OPERATOR {
  color: #ff000000;
}
.syntax-NULL {
  color: #ff000000;
}
.syntax-COMMENT1 {
  color: #ffcc0000;
}
.syntax-COMMENT2 {
  color: #ffff8400;
}
.syntax-COMMENT3 {
  color: #ff6600cc;
}
.syntax-COMMENT4 {
  color: #ffcc6600;
}
.syntax-DIGIT {
  color: #ffff0000;
}
.syntax-FUNCTION {
  color: #ff9966ff;
}
.syntax-INVALID {
  background: #ffffffcc;
  color: #ffff0066;
}
.syntax-KEYWORD1 {
  color: #ff006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #ff009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #ff0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #ff66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #ff02b902;
}
.syntax-LITERAL1 {
  color: #ffff00cc;
}
.syntax-LITERAL2 {
  color: #ffcc00cc;
}
.syntax-LITERAL3 {
  color: #ff9900cc;
}
.syntax-LITERAL4 {
  color: #ff6600cc;
}
.syntax-MARKUP {
  color: #ff0000ff;
}
.syntax-OPERATOR {
  color: #ff000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #ff000000;
}
.syntax-COMMENT1 {
  color: #ffcc0000;
}
.syntax-COMMENT2 {
  color: #ffff8400;
}
.syntax-COMMENT3 {
  color: #ff6600cc;
}
.syntax-COMMENT4 {
  color: #ffcc6600;
}
.syntax-DIGIT {
  color: #ffff0000;
}
.syntax-FUNCTION {
  color: #ff9966ff;
}
.syntax-INVALID {
  background: #ffffffcc;
  color: #ffff0066;
}
.syntax-KEYWORD1 {
  color: #ff006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #ff009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #ff0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #ff66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #ff02b902;
}
.syntax-LITERAL1 {
  color: #ffff00cc;
}
.syntax-LITERAL2 {
  color: #ffcc00cc;
}
.syntax-LITERAL3 {
  color: #ff9900cc;
}
.syntax-LITERAL4 {
  color: #ff6600cc;
}
.syntax-MARKUP {
  color: #ff0000ff;
}
.syntax-OPERATOR {
  color: #ff000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #ffffffff;
}
.syntax-COMMENT1 {
  color: #ff000000;
}
.syntax-COMMENT2 {
  color: #ff000000;
}
.syntax-COMMENT3 {
  color: #ff000000;
}
.syntax-COMMENT4 {
  color: #ff000000;
}
.syntax-DIGIT {
  color: #ff000000;
  font-weight: bold;
  font-style: italic;
}
.syntax-FUNCTION {
  color: #ff000000;
}
.syntax-INVALID {
  color: #ff000000;
}
.syntax-KEYWORD1 {
  color: #ff000000;
}
.syntax-KEYWORD2 {
  color: #ff000000;
}
.syntax-KEYWORD3 {
  color: #ff000000;
}
.syntax-KEYWORD4 {
  color: #ff000000;
}
.syntax-LABEL {
  color: #ff000000;
}

.gutter {
  background: #dbdbdb;
  color: #000000;
  border-right: 2px solid black ;
  margin-right: 5px ;
}
.gutterH {
  background: #dbdbdb;
  color: #990066;
  border-right: 2px solid black ; 
  margin-right: 5px ;
}

--></style>
</head>
<body bgcolor="#ffffffff">
<pre><span class="syntax0"><span class="gutter">   1 </span><span class="syntax-KEYWORD1">theory</span> Insert <span class="syntax-KEYWORD2">imports</span> Find <span class="syntax-LITERAL1">&quot;$SRC/b_pre_monad/Insert_state&quot;</span> <span class="syntax-KEYWORD2">begin</span>
<span class="gutter">   2 </span>
<span class="gutter">   3 </span><span class="syntax-KEYWORD1">type_synonym</span> <span class="syntax-OPERATOR">(</span>'k<span class="syntax-OPERATOR">,</span>'v<span class="syntax-OPERATOR">,</span>'r<span class="syntax-OPERATOR">)</span> fo <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;('k,'v,'r)i12_t&quot;</span>
<span class="gutter">   4 </span><span class="syntax-KEYWORD1">type_synonym</span> <span class="syntax-OPERATOR">(</span>'k<span class="syntax-OPERATOR">,</span>'v<span class="syntax-OPERATOR">,</span>'r<span class="syntax-OPERATOR">,</span>'leaf<span class="syntax-OPERATOR">,</span>'frame<span class="syntax-OPERATOR">)</span> d <span class="syntax-COMMENT1">(* down_state *)</span> <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;('k,'r,'leaf,'frame)find_state*'v&quot;</span>
<span class="gutterH">   5 </span><span class="syntax-KEYWORD1">type_synonym</span> <span class="syntax-OPERATOR">(</span>'k<span class="syntax-OPERATOR">,</span>'v<span class="syntax-OPERATOR">,</span>'r<span class="syntax-OPERATOR">,</span>'frame<span class="syntax-OPERATOR">)</span> u <span class="syntax-COMMENT1">(* up_state *)</span> <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;('k,'v,'r)fo*'frame list&quot;</span>
<span class="gutter">   6 </span>
<span class="gutter">   7 </span><span class="syntax-COMMENT1">(* insert ------------------------------------------------------------ *)</span>
<span class="gutter">   8 </span>
<span class="gutter">   9 </span>
<span class="gutterH">  10 </span><span class="syntax-KEYWORD1">definition</span> step_down <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  11 </span><span class="syntax-LITERAL1">constants &rArr; </span>
<span class="gutter">  12 </span><span class="syntax-LITERAL1">'k ord &rArr; </span>
<span class="gutter">  13 </span><span class="syntax-LITERAL1">('k,'r,'frame,'left_half,'right_half,'node) frame_ops &rArr; </span>
<span class="gutter">  14 </span><span class="syntax-LITERAL1">('r,('node,'leaf)dnode,'t) store_ops &rArr;</span>
<span class="gutterH">  15 </span><span class="syntax-LITERAL1">('k,'v,'r,'leaf,'frame) d &rArr; (('k,'v,'r,'leaf,'frame) d,'t) MM&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">  16 </span><span class="syntax-LITERAL1">&quot;step_down cs k_cmp frame_ops store_ops = (</span>
<span class="gutter">  17 </span><span class="syntax-LITERAL1">  let find_step =  find_step cs k_cmp frame_ops store_ops in</span>
<span class="gutter">  18 </span><span class="syntax-LITERAL1">  (% d.</span>
<span class="gutter">  19 </span><span class="syntax-LITERAL1">  let (fs,v) = d in</span>
<span class="gutterH">  20 </span><span class="syntax-LITERAL1">  find_step fs |&gt; fmap (% d'. (d',v)) ))&quot;</span>
<span class="gutter">  21 </span>
<span class="gutter">  22 </span>
<span class="gutter">  23 </span><span class="syntax-KEYWORD1">definition</span> step_bottom <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  24 </span><span class="syntax-LITERAL1">constants &rArr; </span>
<span class="gutterH">  25 </span><span class="syntax-LITERAL1">'k ord &rArr; </span>
<span class="gutter">  26 </span><span class="syntax-LITERAL1">('k,'v,'leaf) leaf_ops &rArr;</span>
<span class="gutter">  27 </span><span class="syntax-LITERAL1">('k,'r,'node) node_ops &rArr; </span>
<span class="gutter">  28 </span><span class="syntax-LITERAL1">('r,('node,'leaf)dnode,'t) store_ops &rArr;</span>
<span class="gutter">  29 </span><span class="syntax-LITERAL1">('k,'v,'r,'leaf,'frame) d &rArr; (('k,'v,'r,'frame) u + unit,'t) MM&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutterH">  30 </span><span class="syntax-LITERAL1">&quot;step_bottom cs k_cmp leaf_ops node_ops store_ops d = (</span>
<span class="gutter">  31 </span><span class="syntax-LITERAL1">  let (write,rewrite) = (store_ops|&gt;wrte,store_ops|&gt;rewrite) in</span>
<span class="gutter">  32 </span><span class="syntax-LITERAL1">  let mk_leaf = (leaf_ops|&gt;mk_leaf) in</span>
<span class="gutter">  33 </span><span class="syntax-LITERAL1">  let (fs,v) = d in</span>
<span class="gutter">  34 </span><span class="syntax-LITERAL1">  case dest_F_finished fs of </span>
<span class="gutterH">  35 </span><span class="syntax-LITERAL1">  None &rArr; (failwith (STR ''insert, step_bottom, 1''))</span>
<span class="gutter">  36 </span><span class="syntax-LITERAL1">  | Some(r0,k,r,leaf,stk) &rArr; (</span>
<span class="gutter">  37 </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&#8213;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&lsaquo;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">f</span><span class="syntax-LITERAL1">r</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">h</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">r</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">?</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1">I</span><span class="syntax-LITERAL1">X</span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1">E</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&rsaquo;</span>
<span class="gutter">  38 </span><span class="syntax-LITERAL1">    let leaf' = (leaf_ops|&gt;leaf_insert) k v leaf in</span>
<span class="gutter">  39 </span><span class="syntax-LITERAL1">    case (leaf_ops|&gt;leaf_length) leaf' &le; cs|&gt;max_leaf_size of</span>
<span class="gutterH">  40 </span><span class="syntax-LITERAL1">    True &rArr; (</span>
<span class="gutter">  41 </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&#8213;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&lsaquo;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">w</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">w</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">n</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1">o</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">u</span><span class="syntax-LITERAL1">p</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">n</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">p</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">c</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">f</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">p</span><span class="syntax-LITERAL1">o</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">b</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&rsaquo;</span>
<span class="gutter">  42 </span><span class="syntax-LITERAL1">      Disk_leaf leaf' |&gt; rewrite r |&gt; bind (% r'. </span>
<span class="gutter">  43 </span><span class="syntax-LITERAL1">      case r' of </span>
<span class="gutter">  44 </span><span class="syntax-LITERAL1">      None &rArr; </span>
<span class="gutterH">  45 </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&#8213;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&lsaquo;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">b</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">o</span><span class="syntax-LITERAL1">c</span><span class="syntax-LITERAL1">k</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">w</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">u</span><span class="syntax-LITERAL1">p</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">n</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">p</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">c</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&rsaquo;</span>
<span class="gutter">  46 </span><span class="syntax-LITERAL1">        return (Inr ())</span>
<span class="gutter">  47 </span><span class="syntax-LITERAL1">      | Some r' &rArr; return (Inl(I1 r',stk))))</span>
<span class="gutter">  48 </span><span class="syntax-LITERAL1">    | False &rArr; (</span>
<span class="gutter">  49 </span><span class="syntax-LITERAL1">      let kvs' = (leaf_ops|&gt;leaf_kvs) leaf' in</span>
<span class="gutterH">  50 </span><span class="syntax-LITERAL1">      let (kvs1,k',kvs2) = split_leaf cs kvs' in</span>
<span class="gutter">  51 </span><span class="syntax-LITERAL1">      Disk_leaf (mk_leaf kvs1) |&gt; write |&gt; bind (% r1.</span>
<span class="gutter">  52 </span><span class="syntax-LITERAL1">      Disk_leaf (mk_leaf kvs2) |&gt; write |&gt; bind (% r2. </span>
<span class="gutter">  53 </span><span class="syntax-LITERAL1">      return (Inl(I2(r1,k',r2),stk)))))))&quot;</span>
<span class="gutter">  54 </span>
<span class="gutterH">  55 </span>
<span class="gutter">  56 </span>
<span class="gutter">  57 </span><span class="syntax-KEYWORD1">definition</span> step_up <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  58 </span><span class="syntax-LITERAL1">constants &rArr; </span>
<span class="gutter">  59 </span><span class="syntax-LITERAL1">'k ord &rArr; </span>
<span class="gutterH">  60 </span><span class="syntax-LITERAL1">('k,'r,'node) node_ops &rArr; </span>
<span class="gutter">  61 </span><span class="syntax-LITERAL1">('k,'r,'frame,'left_half,'right_half,'node) frame_ops &rArr; </span>
<span class="gutter">  62 </span><span class="syntax-LITERAL1">('r,('node,'leaf)dnode,'t) store_ops &rArr;</span>
<span class="gutter">  63 </span><span class="syntax-LITERAL1">('k,'v,'r,'frame) u &rArr; (('k,'v,'r,'frame) u + unit,'t) MM&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">  64 </span><span class="syntax-LITERAL1">&quot;step_up  cs k_cmp node_ops frame_ops store_ops u = (</span>
<span class="gutterH">  65 </span><span class="syntax-LITERAL1">  let (write,rewrite) = (store_ops|&gt;wrte,store_ops|&gt;rewrite) in</span>
<span class="gutter">  66 </span><span class="syntax-LITERAL1">  let (fo,stk) = u in</span>
<span class="gutter">  67 </span><span class="syntax-LITERAL1">  case stk of </span>
<span class="gutter">  68 </span><span class="syntax-LITERAL1">  [] &rArr; failwith (STR ''insert, step_up,1'') </span>
<span class="gutter">  69 </span><span class="syntax-LITERAL1">  | frm#stk' &rArr; (</span>
<span class="gutterH">  70 </span><span class="syntax-LITERAL1">    let (lh,rh) = ((frame_ops|&gt;left_half) frm, (frame_ops|&gt;right_half) frm) in</span>
<span class="gutter">  71 </span><span class="syntax-LITERAL1">    let original_r = (frame_ops|&gt;original_node_r) frm in</span>
<span class="gutter">  72 </span><span class="syntax-LITERAL1">    case fo of</span>
<span class="gutter">  73 </span><span class="syntax-LITERAL1">    I1 r &rArr; (</span>
<span class="gutter">  74 </span><span class="syntax-LITERAL1">      let n = (frame_ops|&gt;unsplit) (lh,R(r),rh) in</span>
<span class="gutterH">  75 </span><span class="syntax-LITERAL1">      Disk_node(n) |&gt; rewrite original_r |&gt; bind (% r2. </span>
<span class="gutter">  76 </span><span class="syntax-LITERAL1">      case r2 of </span>
<span class="gutter">  77 </span><span class="syntax-LITERAL1">      None &rArr; return (Inr ())</span>
<span class="gutter">  78 </span><span class="syntax-LITERAL1">      | Some r2 &rArr; return (Inl (I1 r2, stk'))))</span>
<span class="gutter">  79 </span><span class="syntax-LITERAL1">    | I2 (r1,k,r2) &rArr; (</span>
<span class="gutterH">  80 </span><span class="syntax-LITERAL1">      let n = (frame_ops|&gt;unsplit) (lh, Rkr(r1,k,r2), rh) in</span>
<span class="gutter">  81 </span><span class="syntax-LITERAL1">      let n = (n :: 'node) in</span>
<span class="gutter">  82 </span><span class="syntax-LITERAL1">      case (node_ops|&gt;node_keys_length) n &le; (cs|&gt;max_node_keys) of</span>
<span class="gutter">  83 </span><span class="syntax-LITERAL1">      True &rArr; (</span>
<span class="gutter">  84 </span><span class="syntax-LITERAL1">        Disk_node(n) |&gt; rewrite original_r |&gt; bind (% r2. </span>
<span class="gutterH">  85 </span><span class="syntax-LITERAL1">        case r2 of </span>
<span class="gutter">  86 </span><span class="syntax-LITERAL1">        None &rArr; return (Inr ())</span>
<span class="gutter">  87 </span><span class="syntax-LITERAL1">        | Some r2 &rArr; return (Inl (I1 r2, stk'))))</span>
<span class="gutter">  88 </span><span class="syntax-LITERAL1">      | False &rArr; (</span>
<span class="gutter">  89 </span><span class="syntax-LITERAL1">        let (n1,k,n2) = (node_ops|&gt;split_large_node) n in  </span>
<span class="gutterH">  90 </span><span class="syntax-LITERAL1">        Disk_node(n1) |&gt; write |&gt; bind (% r1. </span>
<span class="gutter">  91 </span><span class="syntax-LITERAL1">        Disk_node(n2) |&gt; write |&gt; bind (% r2.</span>
<span class="gutter">  92 </span><span class="syntax-LITERAL1">        return (Inl (I2(r1,k,r2),stk'))))) )))&quot;</span>
<span class="gutter">  93 </span>
<span class="gutter">  94 </span>
<span class="gutterH">  95 </span>
<span class="gutter">  96 </span><span class="syntax-KEYWORD1">definition</span> insert_step <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  97 </span><span class="syntax-LITERAL1">constants &rArr; </span>
<span class="gutter">  98 </span><span class="syntax-LITERAL1">'k ord &rArr; </span>
<span class="gutter">  99 </span><span class="syntax-LITERAL1">('k,'v,'leaf) leaf_ops &rArr; </span>
<span class="gutterH"> 100 </span><span class="syntax-LITERAL1">('k,'r,'node) node_ops &rArr; </span>
<span class="gutter"> 101 </span><span class="syntax-LITERAL1">('k,'r,'frame,'left_half,'right_half,'node) frame_ops &rArr; </span>
<span class="gutter"> 102 </span><span class="syntax-LITERAL1">('r,('node,'leaf)dnode,'t) store_ops &rArr;</span>
<span class="gutter"> 103 </span><span class="syntax-LITERAL1">('k,'v,'r,'leaf,'frame) insert_state &rArr; (('k,'v,'r,'leaf,'frame) insert_state,'t) MM&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 104 </span><span class="syntax-LITERAL1">&quot;insert_step cs k_cmp leaf_ops node_ops frame_ops store_ops = (</span>
<span class="gutterH"> 105 </span><span class="syntax-LITERAL1">  let step_down = step_down cs k_cmp frame_ops store_ops in</span>
<span class="gutter"> 106 </span><span class="syntax-LITERAL1">  let step_bottom = step_bottom cs k_cmp leaf_ops node_ops store_ops in</span>
<span class="gutter"> 107 </span><span class="syntax-LITERAL1">  let step_up = step_up  cs k_cmp node_ops frame_ops store_ops in</span>
<span class="gutter"> 108 </span><span class="syntax-LITERAL1">  let write = store_ops|&gt;wrte in</span>
<span class="gutter"> 109 </span><span class="syntax-LITERAL1">  (% s.</span>
<span class="gutterH"> 110 </span><span class="syntax-LITERAL1">  case s of </span>
<span class="gutter"> 111 </span><span class="syntax-LITERAL1">  I_down d &rArr; (</span>
<span class="gutter"> 112 </span><span class="syntax-LITERAL1">    let (fs,v) = d in</span>
<span class="gutter"> 113 </span><span class="syntax-LITERAL1">    case dest_F_finished fs of </span>
<span class="gutter"> 114 </span><span class="syntax-LITERAL1">    None &rArr; (step_down d |&gt; fmap (% d. I_down d))</span>
<span class="gutterH"> 115 </span><span class="syntax-LITERAL1">    | Some _ &rArr; step_bottom d |&gt; bind (% bot.</span>
<span class="gutter"> 116 </span><span class="syntax-LITERAL1">      case bot of </span>
<span class="gutter"> 117 </span><span class="syntax-LITERAL1">      Inr () &rArr; return I_finished_with_mutate</span>
<span class="gutter"> 118 </span><span class="syntax-LITERAL1">      | Inl u &rArr; return (I_up u)))</span>
<span class="gutter"> 119 </span><span class="syntax-LITERAL1">  | I_up u &rArr; (</span>
<span class="gutterH"> 120 </span><span class="syntax-LITERAL1">    let (fo,stk) = u in</span>
<span class="gutter"> 121 </span><span class="syntax-LITERAL1">    case stk of</span>
<span class="gutter"> 122 </span><span class="syntax-LITERAL1">    [] &rArr; (</span>
<span class="gutter"> 123 </span><span class="syntax-LITERAL1">      case fo of </span>
<span class="gutter"> 124 </span><span class="syntax-LITERAL1">      I1 r &rArr; return (I_finished r)</span>
<span class="gutterH"> 125 </span><span class="syntax-LITERAL1">      | I2(r1,k,r2) &rArr; (</span>
<span class="gutter"> 126 </span><span class="syntax-LITERAL1">        (Disk_node((node_ops|&gt;node_make_small_root)(r1,k,r2)) |&gt; write |&gt; bind (% r.</span>
<span class="gutter"> 127 </span><span class="syntax-LITERAL1">        return (I_finished r)))))</span>
<span class="gutter"> 128 </span><span class="syntax-LITERAL1">    | _ &rArr; (step_up u |&gt; bind (% u. </span>
<span class="gutter"> 129 </span><span class="syntax-LITERAL1">      case u of </span>
<span class="gutterH"> 130 </span><span class="syntax-LITERAL1">      Inr () &rArr; return I_finished_with_mutate</span>
<span class="gutter"> 131 </span><span class="syntax-LITERAL1">      | Inl u &rArr; return (I_up u))))</span>
<span class="gutter"> 132 </span><span class="syntax-LITERAL1">  | I_finished _ &rArr; (failwith (STR ''insert_step 1'')) </span>
<span class="gutter"> 133 </span><span class="syntax-LITERAL1">  | I_finished_with_mutate &rArr; (failwith (STR ''insert_step 2''))))&quot;</span>
<span class="gutter"> 134 </span>
<span class="gutterH"> 135 </span><span class="syntax-KEYWORD1">definition</span> insert_big_step <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 136 </span><span class="syntax-LITERAL1">constants &rArr; </span>
<span class="gutter"> 137 </span><span class="syntax-LITERAL1">'k ord &rArr; </span>
<span class="gutter"> 138 </span><span class="syntax-LITERAL1">('k,'v,'leaf) leaf_ops &rArr;</span>
<span class="gutter"> 139 </span><span class="syntax-LITERAL1">('k,'r,'node) node_ops &rArr; </span>
<span class="gutterH"> 140 </span><span class="syntax-LITERAL1">('k,'r,'frame,'left_half,'right_half,'node) frame_ops &rArr; </span>
<span class="gutter"> 141 </span><span class="syntax-LITERAL1">('r,('node,'leaf)dnode,'t) store_ops &rArr;</span>
<span class="gutter"> 142 </span><span class="syntax-LITERAL1">('k,'v,'r,'leaf,'frame) insert_state &rArr; (('k,'v,'r,'leaf,'frame) insert_state,'t) MM&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 143 </span><span class="syntax-LITERAL1">&quot;insert_big_step cs k_cmp leaf_ops node_ops frame_ops store_ops = (</span>
<span class="gutter"> 144 </span><span class="syntax-LITERAL1">  let insert_step = insert_step cs k_cmp leaf_ops node_ops frame_ops store_ops in</span>
<span class="gutterH"> 145 </span><span class="syntax-LITERAL1">  (% i.</span>
<span class="gutter"> 146 </span><span class="syntax-LITERAL1">  iter_m (% i. case i of</span>
<span class="gutter"> 147 </span><span class="syntax-LITERAL1">    I_finished r &rArr; (return None)</span>
<span class="gutter"> 148 </span><span class="syntax-LITERAL1">    | I_finished_with_mutate &rArr; (return None)</span>
<span class="gutter"> 149 </span><span class="syntax-LITERAL1">    | _ &rArr; (insert_step i |&gt; fmap Some))</span>
<span class="gutterH"> 150 </span><span class="syntax-LITERAL1">    i))&quot;</span>
<span class="gutter"> 151 </span>
<span class="gutter"> 152 </span><span class="syntax-KEYWORD1">definition</span> insert <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 153 </span><span class="syntax-LITERAL1">constants &rArr; </span>
<span class="gutter"> 154 </span><span class="syntax-LITERAL1">'k ord &rArr;</span>
<span class="gutterH"> 155 </span><span class="syntax-LITERAL1">('k,'v,'leaf) leaf_ops &rArr;</span>
<span class="gutter"> 156 </span><span class="syntax-LITERAL1">('k,'r,'node) node_ops &rArr; </span>
<span class="gutter"> 157 </span><span class="syntax-LITERAL1">('node &rArr; 'r s) &rArr; </span>
<span class="gutter"> 158 </span><span class="syntax-LITERAL1">('node &rArr; 'k s) &rArr; </span>
<span class="gutter"> 159 </span><span class="syntax-LITERAL1">('k,'r,'frame,'left_half,'right_half,'node) frame_ops &rArr; </span>
<span class="gutterH"> 160 </span><span class="syntax-LITERAL1">('r,('node,'leaf)dnode,'t) store_ops &rArr;</span>
<span class="gutter"> 161 </span><span class="syntax-LITERAL1">'r &rArr; 'k &rArr; 'v &rArr; ('r option,'t) MM&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 162 </span><span class="syntax-LITERAL1">&quot;insert cs k_cmp leaf_ops node_ops node2rs node2ks frame_ops store_ops r k v = (</span>
<span class="gutter"> 163 </span><span class="syntax-LITERAL1">  let check_tree_at_r = check_tree_at_r cs k_cmp leaf_ops node_ops node2rs node2ks store_ops in</span>
<span class="gutter"> 164 </span><span class="syntax-LITERAL1">  let i = make_initial_insert_state r k v in</span>
<span class="gutterH"> 165 </span><span class="syntax-LITERAL1">  insert_big_step cs k_cmp leaf_ops node_ops frame_ops store_ops i |&gt; bind (% i.</span>
<span class="gutter"> 166 </span><span class="syntax-LITERAL1">  case i of</span>
<span class="gutter"> 167 </span><span class="syntax-LITERAL1">  I_finished r &rArr; (check_tree_at_r r |&gt; bind (% _. return (Some r)))</span>
<span class="gutter"> 168 </span><span class="syntax-LITERAL1">  | I_finished_with_mutate &rArr; (check_tree_at_r r |&gt; bind (% _. return None))</span>
<span class="gutter"> 169 </span><span class="syntax-LITERAL1">  | _ &rArr; failwith (STR ''insert 1'')</span>
<span class="gutterH"> 170 </span><span class="syntax-LITERAL1">))&quot;</span>
<span class="gutter"> 171 </span>
<span class="gutter"> 172 </span>
<span class="gutter"> 173 </span>
<span class="gutter"> 174 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutterH"> 175 </span>
<span class="gutter"> 176 </span>
<span class="gutter"> 177 </span>
<span class="gutter"> 178 </span>
<span class="gutter"> 179 </span>
<span class="gutterH"> 180 </span><span class="syntax-COMMENT1">(*</span>
<span class="gutter"> 181 </span><span class="syntax-COMMENT1">export_code  </span>
<span class="gutter"> 182 </span><span class="syntax-COMMENT1">&quot;Code_Numeral.int_of_integer&quot;</span>
<span class="gutter"> 183 </span><span class="syntax-COMMENT1">fmap</span>
<span class="gutter"> 184 </span><span class="syntax-COMMENT1">Disk_node</span>
<span class="gutterH"> 185 </span><span class="syntax-COMMENT1">make_constants</span>
<span class="gutter"> 186 </span><span class="syntax-COMMENT1">make_store_ops</span>
<span class="gutter"> 187 </span><span class="syntax-COMMENT1">make_initial_find_state</span>
<span class="gutter"> 188 </span><span class="syntax-COMMENT1">I1</span>
<span class="gutter"> 189 </span><span class="syntax-COMMENT1">I_down</span>
<span class="gutterH"> 190 </span><span class="syntax-COMMENT1">insert_step</span>
<span class="gutter"> 191 </span>
<span class="gutter"> 192 </span><span class="syntax-COMMENT1">in OCaml file &quot;/tmp/insert_with_mutation.ml&quot;</span>
<span class="gutter"> 193 </span><span class="syntax-COMMENT1">*)</span>
</span></pre>
</body>
</html>
