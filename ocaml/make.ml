(* Construct a B-tree *)


(** This functor takes various types and constants (including, in
   particular, the type of keys and the value for the comparison on
   keys) and generates extra types [leaf,node,leaf_stream...] for the map
   implementations. Then there is a function [make_btree_ops] which
   takes a [store_ops] and returns the B-tree operations.

   Note that these are "pre_btree_ops" because they expose internal
   types that we may want to hide: leaf, node, frame, leaf_stream(?).
   See package tjr_btree for the simpler versions.

 *)

(* $(FIXME("""
- why pre_map_ops and pre_btree_ops?
- get pp versions of eg pre_btree_ops and 

""")) *)

open Constants
open Isa_btree_intf

(* $(PIPE2SH("""sed -n '/Argument[ ]to Make/,/^end/p' >GEN.S.ml_""")) *)
(** Argument to Make functor *)
module type S = sig 
  type k
  type v
  type r
  type t
  val k_cmp     : k -> k -> int
  val monad_ops : t monad_ops
  val cs        : constants
end

(* $(PIPE2SH("""sed -n '/Result[ ]of Make/,/^end/p' >GEN.T.ml_""")) *)
(** Result of Make functor *)
module type T = sig
  module S : S
  open S

  type leaf 
  type node
  type leaf_stream

  (** NOTE leaf_ops and node_ops are used externally to convert
     to/from lists *)
  val leaf_ops: (k,v,leaf)leaf_ops
  val node_ops: (k,r,node)node_ops

  val make_btree_ops: 
    store_ops:(r, (node, leaf) dnode, t) store_ops ->
    (k, v, r, t, leaf, node, leaf_stream) pre_btree_ops
end


(** Version with full sig *)
module Make_v1(S:S) = struct
  open Isa_export_wrapper

  module S = S
  open S

  module Map_ops = Isa_btree_util.Internal_make_map_ops(
    struct 
      type nonrec k = k 
      let k_cmp = k_cmp 
    end)
  include Map_ops

  type node = (k option, r, kopt_comparator) Base.Map.t
  type leaf = (k, v, k_comparator) Base.Map.t
  type frame = (k, r, node) Frame_type.frame
  type leaf_stream = (r, leaf, frame) Internal_leaf_stream_impl._t

  let dbg_tree_at_r = fun _ -> monad_ops.return () 

  let x = 
    Isa_export_wrapper.make_with_k_maps 
      ~monad_ops 
      ~cs 
      ~k_cmp 
      ~k_map:(k_map ()) 
      ~kopt_map:(kopt_map()) 
      ~dbg_tree_at_r

  let leaf_ops = x.leaf_ops

  let node_ops = x.node_ops

  let make_btree_ops 
      ~(store_ops:(r,(node,leaf)dnode,t)store_ops)
    : (k,v,r,t,leaf,node,leaf_stream)pre_btree_ops
    = 
    x.rest ~store_ops

  let _ = make_btree_ops
end


(** Version with restricted sig *)
module Make_v2(S:S) : T with module S=S = struct
  include Make_v1(S)
end


(** NOTE make as a function is difficult because of the types
   (leaf,node,leaf_stream) generated by the functor *)
  
(* type ('k,'v,'r,'t) btree = (module T with type S.k='k and type S.v='v and type S.r='r and type S.t='t) *)
