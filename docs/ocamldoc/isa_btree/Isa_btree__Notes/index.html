<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Isa_btree__Notes (isa_btree.Isa_btree__Notes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">isa_btree</a> &#x00BB; Isa_btree__Notes</nav><h1>Module <code>Isa_btree__Notes</code></h1><p>Some notes on constructing the B-tree</p></header><aside><p>In order to construct B-trees dynamically, without first-order modules, we have used an approach based on parametric records of operations. However, this gets unwieldy (too many type parameters!). Here we look at an approach based on first-order modules. The downside is that we need quite a few type sharing annotations to get things to work.</p></aside><dl><dt class="spec module-type" id="module-type-Sa"><a href="#module-type-Sa" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Sa/index.html">Sa</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The basic types, and background monad_ops and cs and k_cmp.</p></dd></dl><div class="spec module-type" id="module-type-Sb"><a href="#module-type-Sb" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Sb/index.html">Sb</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-Sc"><a href="#module-type-Sc" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Sc/index.html">Sc</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-Ta"><a href="#module-type-Ta" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Ta/index.html">Ta</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-Tb"><a href="#module-type-Tb" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Tb/index.html">Tb</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The advantage of this impl is that we avoid type generativity; of course, that means we are free to mess up different map types.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Tc"><a href="#module-type-Tc" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Tc/index.html">Tc</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This fixes the implementation of leaf and node as Base.Map.t. Fine for testing, but we probably prefer Ta for development since we don't want to assume impls of leaf and node. Alternatively, take a pre_btree_ops and work with that.</p></dd></dl><div class="spec module-type" id="module-type-Tc'"><a href="#module-type-Tc'" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Tc'/index.html">Tc'</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>