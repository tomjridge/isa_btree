--- orig/isa_export.ml	2019-03-29 13:34:13.416472267 +0000
+++ patched/isa_export.ml	2019-04-01 10:11:54.655459340 +0100
@@ -1,3 +1,17 @@
+(** This file is exported from Isabelle, and lightly patched (eg to
+   include this comment!). The OCaml interfaces wrap this basic
+   functionality. *)
+
+let check_flag = ref true
+
+module type MONAD = sig
+   type ('a, 'b) mm
+   val bind : ('a -> ('b, 'c) mm) -> ('a, 'c) mm -> ('b, 'c) mm
+   val fmap : ('a -> 'b) -> ('a, 'c) mm -> ('b, 'c) mm
+   val return : 'a -> ('a, 'b) mm
+end
+
+
 module Fun : sig
   val id : 'a -> 'a
   val comp : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
@@ -71,7 +85,7 @@ let rec max _A a b = (if less_eq _A a b
 end;; (*struct Orderings*)
 
 module Arith : sig
-  type nat
+  type nat = Nat of Big_int.big_int
   val equal_nata : nat -> nat -> bool
   val equal_nat : nat HOL.equal
   val less_eq_nat : nat -> nat -> bool
@@ -1523,6 +1537,8 @@ let rec return x = failwith "undefined";
 
 end;; (*struct Monad*)
 
+module Make(Monad:MONAD) = struct
+
 module Post_monad : sig
   type ('a, 'b, 'c) store_ops =
     Make_store_ops of
@@ -2515,3 +2531,5 @@ let rec make_initial_im_state
     (let i = Insert_state.make_initial_insert_state r k v in (i, kvs));;
 
 end;; (*struct Insert_many_state*)
+
+end (* Make *)
