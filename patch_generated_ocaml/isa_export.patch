--- isa_export.ml.orig	2019-02-05 17:05:34.926818866 +0000
+++ isa_export.ml	2019-02-05 17:05:37.838891115 +0000
@@ -1,3 +1,19 @@
+(** This file is exported from Isabelle, and lightly patched (eg to
+   include this comment!). The OCaml interfaces wrap this basic
+   functionality. *)
+
+let check_flag = ref true
+
+module type MONAD = sig
+   type ('a, 'b) mm
+   val bind : ('a -> ('b, 'c) mm) -> ('a, 'c) mm -> ('b, 'c) mm
+   val fmap : ('a -> 'b) -> ('a, 'c) mm -> ('b, 'c) mm
+   val return : 'a -> ('a, 'b) mm
+end
+
+
+
+
 module Fun : sig
   val id : 'a -> 'a
   val comp : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
@@ -270,7 +286,7 @@ end;; (*struct Set*)
 module Constants_and_size_types : sig
   type constants =
     Make_constants of Arith.nat * Arith.nat * Arith.nat * Arith.nat
-  type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf
+  type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf [@@deriving yojson]
   val make_constants :
     Arith.nat -> Arith.nat -> Arith.nat -> Arith.nat -> constants
   val max_leaf_size : constants -> Arith.nat
@@ -282,7 +298,7 @@ end = struct
 type constants =
   Make_constants of Arith.nat * Arith.nat * Arith.nat * Arith.nat;;
 
-type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf;;
+type min_size_t = Small_root_node_or_leaf | Small_node | Small_leaf [@@deriving yojson];;
 
 let rec make_constants a b c d = Make_constants (a, b, c, d);;
 
@@ -306,7 +322,7 @@ let rec is_none = function Some x -> fal
 end;; (*struct Option*)
 
 module A_start_here : sig
-  type error = String_error of string
+  type error = String_error of string [@@deriving yojson]
   val from_to : Arith.nat -> Arith.nat -> Arith.nat list
   val is_Nil : 'a list -> bool
   val rev_apply : 'a -> ('a -> 'b) -> 'b
@@ -320,7 +336,7 @@ module A_start_here : sig
   val get_check_flag : unit -> bool
 end = struct
 
-type error = String_error of string;;
+type error = String_error of string [@@deriving yojson];;
 
 let rec from_to x y = Lista.upt x (Arith.suc y);;
 
@@ -328,12 +344,12 @@ let rec is_Nil x = (match x with [] -> t
 
 let rec rev_apply x f = f x;;
 
-let rec failwitha x = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec failwitha x = failwith x;;
 
 let rec iter_step
   f x = (let a = f x in (match a with None -> x | Some aa -> iter_step f aa));;
 
-let rec check_true f = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec check_true f = if !check_flag then (let b = f () in assert(b);b) else true;;
 
 let rec assert_true b = (if b then b else failwitha "assert_true");;
 
@@ -369,12 +385,12 @@ let from_to_tests : bool
            in
           true));;
 
-let rec get_check_flag uu = failwitha "FIXME patch";;
+let rec get_check_flag uu = !check_flag
 
 end;; (*struct A_start_here*)
 
 module Key_value : sig
-  type compare_t = LT | EQ | GT
+  type compare_t = LT | EQ | GT [@@deriving yojson]
   val key_eq : ('a -> 'a -> Arith.int) -> 'a -> 'a -> bool
   val key_le : ('a -> 'a -> Arith.int) -> 'a -> 'a -> bool
   val key_lt : ('a -> 'a -> Arith.int) -> 'a -> 'a -> bool
@@ -390,7 +406,7 @@ module Key_value : sig
   val kvs_insert_tests : bool
 end = struct
 
-type compare_t = LT | EQ | GT;;
+type compare_t = LT | EQ | GT [@@deriving yojson];;
 
 let rec key_eq ord k1 k2 = Arith.equal_int (ord k1 k2) Arith.zero_int;;
 
@@ -552,7 +568,7 @@ let kvs_insert_tests : bool
 end;; (*struct Key_value*)
 
 module Stacks_and_frames : sig
-  type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd)))
+  type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd))) [@@deriving yojson]
   val dest_Frm : ('a, 'b, 'c, 'd) stk_frame -> 'a * ('b * ('c * 'd))
   val get_bounds :
     (('a list * 'b list), 'a, ('b list * 'a list), 'a) stk_frame list ->
@@ -569,7 +585,7 @@ module Stacks_and_frames : sig
       'b list * 'a list
 end = struct
 
-type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd)));;
+type ('a, 'b, 'c, 'd) stk_frame = Frm of ('a * ('b * ('c * 'd))) [@@deriving yojson];;
 
 let rec dest_Frm (Frm (a, (b, (c, d)))) = (a, (b, (c, d)));;
 
@@ -667,13 +683,13 @@ end;; (*struct Stacks_and_frames*)
 
 module Disk_node : sig
   type ('a, 'b, 'c) dnode = Disk_node of ('a list * 'c list) |
-    Disk_leaf of ('a * 'b) list
+    Disk_leaf of ('a * 'b) list [@@deriving yojson]
   val dest_Disk_leaf : ('a, 'b, 'c) dnode -> ('a * 'b) list
   val dest_Disk_node : ('a, 'b, 'c) dnode -> 'a list * 'c list
 end = struct
 
 type ('a, 'b, 'c) dnode = Disk_node of ('a list * 'c list) |
-  Disk_leaf of ('a * 'b) list;;
+  Disk_leaf of ('a * 'b) list [@@deriving yojson];;
 
 let rec dest_Disk_leaf
   f = (match f with Disk_node _ -> A_start_here.failwitha "dest_Disk_leaf"
@@ -696,7 +712,7 @@ module Leaf_stream_state : sig
             Stacks_and_frames.stk_frame list)
     | LS_up of
         (('c list * 'a list), 'c, ('a list * 'c list), 'c)
-          Stacks_and_frames.stk_frame list
+          Stacks_and_frames.stk_frame list [@@deriving yojson]
   val dest_LS_leaf : ('a, 'b, 'c) lss -> (('a * 'b) list) option
   val lss_is_finished : ('a, 'b, 'c) lss -> bool
   val make_initial_lss : 'a -> ('b, 'c, 'a) lss
@@ -712,7 +728,7 @@ type ('a, 'b, 'c) lss =
           Stacks_and_frames.stk_frame list)
   | LS_up of
       (('c list * 'a list), 'c, ('a list * 'c list), 'c)
-        Stacks_and_frames.stk_frame list;;
+        Stacks_and_frames.stk_frame list [@@deriving yojson];;
 
 let rec dest_LS_leaf
   x = (match x with LS_down _ -> None | LS_leaf (kvs, _) -> Some kvs
@@ -734,7 +750,7 @@ module Find_state : sig
     | F_finished of
         ('c * ('a * ('c * (('a * 'b) list *
                             (('c list * 'a list), 'c, ('a list * 'c list), 'c)
-                              Stacks_and_frames.stk_frame list))))
+                              Stacks_and_frames.stk_frame list)))) [@@deriving yojson]
   val dest_F_finished :
     ('a, 'b, 'c) find_state ->
       ('c * ('a * ('c * (('a * 'b) list *
@@ -750,7 +766,7 @@ type ('a, 'b, 'c) find_state =
   | F_finished of
       ('c * ('a * ('c * (('a * 'b) list *
                           (('c list * 'a list), 'c, ('a list * 'c list), 'c)
-                            Stacks_and_frames.stk_frame list))));;
+                            Stacks_and_frames.stk_frame list)))) [@@deriving yojson];;
 
 let rec dest_F_finished
   fs = (match fs with F_down _ -> None
@@ -762,14 +778,14 @@ let rec make_initial_find_state k r = F_
 end;; (*struct Find_state*)
 
 module Insert_state : sig
-  type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c))
+  type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c)) [@@deriving yojson]
   type ('a, 'b, 'c) insert_state =
     I_down of (('a, 'b, 'c) Find_state.find_state * 'b) |
     I_up of
       (('a, 'b, 'c) i12_t *
         (('c list * 'a list), 'c, ('a list * 'c list), 'c)
           Stacks_and_frames.stk_frame list)
-    | I_finished of 'c | I_finished_with_mutate
+    | I_finished of 'c | I_finished_with_mutate [@@deriving yojson]
   val split_leaf :
     Constants_and_size_types.constants ->
       ('a * 'b) list -> ('a * 'b) list * ('a * ('a * 'b) list)
@@ -779,7 +795,7 @@ module Insert_state : sig
   val make_initial_insert_state : 'a -> 'b -> 'c -> ('b, 'c, 'a) insert_state
 end = struct
 
-type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c));;
+type ('a, 'b, 'c) i12_t = I1 of 'c | I2 of ('c * ('a * 'c)) [@@deriving yojson];;
 
 type ('a, 'b, 'c) insert_state =
   I_down of (('a, 'b, 'c) Find_state.find_state * 'b) |
@@ -787,7 +803,7 @@ type ('a, 'b, 'c) insert_state =
     (('a, 'b, 'c) i12_t *
       (('c list * 'a list), 'c, ('a list * 'c list), 'c)
         Stacks_and_frames.stk_frame list)
-  | I_finished of 'c | I_finished_with_mutate;;
+  | I_finished of 'c | I_finished_with_mutate [@@deriving yojson];;
 
 let rec split_leaf
   cs kvs =
@@ -856,7 +872,7 @@ end;; (*struct Insert_many_state*)
 
 module Delete_state : sig
   type ('a, 'b, 'c) del_t = D_small_leaf of ('a * 'b) list |
-    D_small_node of ('a list * 'c list) | D_updated_subtree of 'c
+    D_small_node of ('a list * 'c list) | D_updated_subtree of 'c [@@deriving yojson]
   type ('a, 'b, 'c) delete_state =
     D_down of (('a, 'b, 'c) Find_state.find_state * 'c) |
     D_up of
@@ -864,13 +880,13 @@ module Delete_state : sig
         ((('c list * 'a list), 'c, ('a list * 'c list), 'c)
            Stacks_and_frames.stk_frame list *
           'c))
-    | D_finished of 'c
+    | D_finished of 'c [@@deriving yojson]
   val dest_D_finished : ('a, 'b, 'c) delete_state -> 'c option
   val make_initial_delete_state : 'a -> 'b -> ('b, 'c, 'a) delete_state
 end = struct
 
 type ('a, 'b, 'c) del_t = D_small_leaf of ('a * 'b) list |
-  D_small_node of ('a list * 'c list) | D_updated_subtree of 'c;;
+  D_small_node of ('a list * 'c list) | D_updated_subtree of 'c [@@deriving yojson];;
 
 type ('a, 'b, 'c) delete_state =
   D_down of (('a, 'b, 'c) Find_state.find_state * 'c) |
@@ -879,7 +895,7 @@ type ('a, 'b, 'c) delete_state =
       ((('c list * 'a list), 'c, ('a list * 'c list), 'c)
          Stacks_and_frames.stk_frame list *
         'c))
-  | D_finished of 'c;;
+  | D_finished of 'c [@@deriving yojson];;
 
 let rec dest_D_finished
   x = (match x with D_down _ -> None | D_up _ -> None
@@ -900,7 +916,7 @@ end;; (*struct Sum_Type*)
 
 module Tree : sig
   type ('a, 'b) tree = Node of ('a list * ('a, 'b) tree list) |
-    Leaf of ('a * 'b) list
+    Leaf of ('a * 'b) list [@@deriving yojson]
   val wf_tree :
     Constants_and_size_types.constants ->
       Constants_and_size_types.min_size_t option ->
@@ -910,7 +926,7 @@ module Tree : sig
 end = struct
 
 type ('a, 'b) tree = Node of ('a list * ('a, 'b) tree list) |
-  Leaf of ('a * 'b) list;;
+  Leaf of ('a * 'b) list [@@deriving yojson];;
 
 let rec tree_to_subtrees
   t0 = (match t0
@@ -1122,6 +1138,7 @@ let rec return x = failwith "undefined";
 
 end;; (*struct Monad*)
 
+module Make(Monad:MONAD) = struct
 module Post_monad : sig
   type ('a, 'b, 'c) store_ops =
     Make_store_ops of
@@ -2039,3 +2056,5 @@ let rec lss_step
       | Leaf_stream_state.LS_up x -> Monad.return (step_up x));;
 
 end;; (*struct Leaf_stream*)
+
+end (* Make *)
