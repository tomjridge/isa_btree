--- orig/isa_export.ml	2019-04-04 14:09:57.868681749 +0100
+++ patched/isa_export.ml	2019-04-04 15:42:37.233026852 +0100
@@ -1,3 +1,17 @@
+(** This file is exported from Isabelle, and lightly patched (eg to
+   include this comment!). The OCaml interfaces wrap this basic
+   functionality. *)
+
+let check_flag = ref true
+
+module type MONAD = sig
+   type ('a, 'b) mm
+   val bind : ('a -> ('b, 'c) mm) -> ('a, 'c) mm -> ('b, 'c) mm
+   val fmap : ('a -> 'b) -> ('a, 'c) mm -> ('b, 'c) mm
+   val return : 'a -> ('a, 'b) mm
+end
+
+
 module Fun : sig
   val id : 'a -> 'a
   val comp : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
@@ -71,7 +85,7 @@ let rec max _A a b = (if less_eq _A a b
 end;; (*struct Orderings*)
 
 module Arith : sig
-  type nat
+  type nat = Nat of Big_int.big_int
   val equal_nata : nat -> nat -> bool
   val equal_nat : nat HOL.equal
   val less_eq_nat : nat -> nat -> bool
@@ -711,7 +725,7 @@ let rec rbt_min x = rbt_mina x None;;
 
 let rec rev_apply x f = f x;;
 
-let rec failwitha x = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec failwitha x = failwith x
 
 let rec dest_Some = function Some x -> x
                     | None -> failwith "undefined";;
@@ -719,7 +733,7 @@ let rec dest_Some = function Some x -> x
 let rec iter_step
   f x = (let a = f x in (match a with None -> x | Some aa -> iter_step f aa));;
 
-let rec check_true f = rev_apply "FIXME patch" (fun _ -> failwith "undefined");;
+let rec check_true f = let r = f() in assert r; r
 
 let rec assert_true b = (if b then b else failwitha "assert_true");;
 
@@ -1530,6 +1544,8 @@ let rec return x = failwith "undefined";
 
 end;; (*struct Monad*)
 
+module Make(Monad:MONAD) = struct
+
 module Post_monad : sig
   type ('a, 'b, 'c) store_ops =
     Make_store_ops of
@@ -2547,3 +2563,5 @@ let rec make_initial_im_state
     (let i = Insert_state.make_initial_insert_state r k v in (i, kvs));;
 
 end;; (*struct Insert_many_state*)
+
+end (* Make *)
